---
title: "컴퓨터구조 - 명령어와 데이터"
##categories: blog
---


컴퓨터 구조에서 명령어와 데이터는 매우 중요하다. 명령어는 CPU에게 어떤 연산을 수행시킬지, 데이터는 CPU에게 수행되어질 자료 역할을 한다.  

이 페이지에서 명령어와 데이터에 대해 알아보자.

## 명령어와 데이터
**명령어<sup>Instruction</sup>**란, 컴퓨터 프로그램이 프로세서에 특정 작업을 수행하도록 지시하는 명령을 의미한다. 우리가 평소에 개발할 때 사용되는 C++, Python 같은 High-level 언어를 포함해 기계어<sup>Machine Code</sup>, 어셈블리어<sup>Assembly</sup> 같은 저수준 언어 모두 명령어의 종류이다.

**데이터<sup>Data</sup>**란, 컴퓨터에 의해 사용, 해석 되어질 수 있는 정보를 의미한다. 데이터는 때에 따라 숫자, 사진, 영상 등 다양한 종류가 될 수 있다.

명령어와 데이터 중에서 먼저 명령어를 알아볼 것이다.

## 명령어의 형식과 구조
전통적으로 명령어는 다음과 같이 구성된다.

<center><img src="/assets/images/CS_Instruction/Instruction_Architecture.png"></center><br>
명령어는 연산 코드와 오퍼랜드로 구성되어 있다.

**연산 코드<sup>Operation Code</sup>**, 줄여서 OP Code는 명령어가 수행할 연산을 의미하고, **오퍼랜드<sup>Operand</sup>**는 연산에 사용할 데이터가 저장된 위치를 의미한다.
연산 코드는 연산자, 오퍼랜드는 피연산자라고도 불린다.
<!-- (I-Type, J-Type, R-Type 추가 공부 필요) -->
<br><br>

<h3>연산 코드</h3>

<center><img src="/assets/images/CS_Instruction/Instruction_1.png"></center><br>
컴퓨터에게 수행할 연산을 명령 시키는 만큼 다양한 종류의 연산 코드를 가지고 있다. 가장 기본적인 연산 코드 유형은 크게 네 가지로 나눌 수 있다.

1. 데이터 전송
2. 산술/논리 연산
3. 제어 흐름 변경
4. 입출력 제어

각 유형에 해당하는 ADD나 MOVE같은 명령어들이 있지만, CPU 마다 다르기에 이 페이지에서는 다루지 않겠다.


<h3>오퍼랜드</h3>

'연산에 사용할 데이터' 또는 '연산에 사용될 데이터가 저장된 위치'를 의미한다. 그래서 오퍼랜드 필드에는 숫자 같은 데이터나 메모리, 레지스터 주소가 담겨 있다.
다만 사용할 데이터를 직접 명시하기 보단 주로 메모리 주소, 레지스터 주소가 담긴다. 
그래서 오퍼랜드 필드를 주소 필드라고도 부른다.

<center><img src="/assets/images/CS_Instruction/Instruction_2.png"></center><br>
효율성을 위해 오퍼랜드는 명령어 안에 하나도 없을 수도 있고, 한 개만 있을 수도 있고, 두 개 또는 세 개 등 여러 개가 있을 수 있다.
따라서 명령어들을 오퍼랜드 개수에 따라 0-주소 명령어, 1-주소 명령어, 2-주소 명령어, 3-주소 명령어로 분류 할 수 있다.

<h3>0-주소 명령어</h3>

<center><img src="/assets/images/CS_Instruction/zero.png"></center><br>
연산 코드만 존재하고 주소를 지정하는 오퍼랜드가 존재하지 않는 명령어 형식이다.
0-주소 명령어는 오퍼랜드가 없는 대신 CPU내에 스택 포인터를 통해 스택 메모리의 맨 위(TOP)에서 데이터를 가져와서 연산한다.  

명령어 형식이 짧아 명령 수행 시간이 짧고, 스택을 활용해 하드웨어를 간결하게 사용할 수 있다.
하지만 모든 연산이 Stack 기준이므로 복잡한 계산일 경우 많은 PUSH/POP이 필요해 일반적으로 비효율적이라는 단점이 있다.

    0주소 명령어의 예시
    (3 + 4) * 5를 구현할 때
    PUSH 3
    PUSH 4
    ADD
    PUSH 5
    MUL

연산 순서는 Stack에서의 최적화를 위해 **후위표기법<sup>Postfix</sup>**을 사용한다.

<h3>1-주소 명령어</h3>

<center><img src="/assets/images/CS_Instruction/one.png"></center><br>
오퍼랜드 한 개만 포함하는 명령어 형식이다. **누산기<sup>Accumulator</sup>** 줄여서 ACC를 이용하여 수행 결과를 누산기에 저장하여 작동한다.
오퍼랜드에는 레지스터 주소와 메모리 주소 모두 들어갈 수 있지만 일반적으로 메모리 주소로 설명한다.
그렇게 된 이유로는 1-주소 명령어가 사용된 초기(EDSAC, IBM 701)명령어 구조 때는 범용 레지스터가 제한적이었기 때문이다.
<!-- 왜 범용 레지스터가 아니라 누산기로 사용했는가? -->

    1-주소 명령어의 예시
    LOAD A      ; ACC ← Mem[A]
    ADD B       ; ACC ← ACC + Mem[B]
    STORE C     ; Mem[C] ← ACC

1-주소 명령어도 하드웨어가 단순하고, 명령어 포멧이 작아 0-주소 명령어 만큼은 아니지만 메모리 절약을 할 수 있다.


<h3>2-주소 명령어</h3>

<center><img src="/assets/images/CS_Instruction/two.png"></center><br>
오퍼랜드 두 개를 포함하는 명령어로서, 오퍼랜드 2개 모두 주소를 저장한다.
1-주소 명령어는 ACC로 고정하여 계산하는 방식이었다면, 2-주소 명령어에서는 두 개를 받아 나중에 받은 값을 처음 받은 값에 더해서 덮어 씌우는 방식이다.
과거 1960-1980년대 상업용 시스템에서 많이 사용되었으나 파이프라인의 비효율성 문제로 현재 RISC 구조에서는 거의 사용되지 않는다.

    2-주소 명령어의 예시
    ADD R1, R2, R3 → R1 = R2 + R3 로 처리됨


<h3>3-주소 명령어</h3>

<center><img src="/assets/images/CS_Instruction/three.png"></center><br>
오퍼랜드 세 개를 포함하는 명령어이다.
앞에서 소개한 명령어 형식과 달리 3-주소 명령어는 중간 결과를 덮어쓰지 않고 계산을 할 수 있다.


    2- 주소 명령어
    MOV E, A      ; E ← A
    ADD E, B      ; E ← E + B   → 중간 결과 E = A + B
    MUL E, C      ; E ← E * C   → 최종 결과
    중간 결과가 계속 같은 공간인 E에 저장되며 이전 값이 없어지지만

    이지만
    3-주소 명령어
    ADD T1, A, B   ; T1 ← A + B      → 중간 결과를 T1에 저장
    MUL E, T1, C   ; E ← T1 * C      → 최종 결과를 E에 저장
    에선 중간 결과가 덮어지지 않음


3-구조 명령어에 맞춰 규격화(파이프라이닝)을 하여 현재 ARM, RISC-V에서 널리 사용되는 방식이다.
명령어의 길이가 길어질수록 연산 효율성이 좋아지지만 명령어의 길이가 길어진 다는 단점이 존재한다.


## 명령어 주소 지정 방식


명령어의 길이는 제한적이다. 그렇기에 최대한 효율적으로 명령어를 사용해야 한다.
만약 하나의 명령어가 n비트를 가지고, 연산 코드가 m비트를 가질 경우, 사용할 수 있는 오퍼랜드의 길이는 n-m비트이다.
또한 오퍼랜드 요구 수에 따라 나뉘면 사용할 수 있는 비트는 더더욱 줄어들게 된다.

따라서 명령어는 고정된 비트 수를 가지므로, 다양한 연산을 최대한 효율적으로 처리해야 하는데,
이를 해결하기 위해 다양한 **주소 지정 방식<sup>Addressing Modes</sup>**이 있다.

실제 컴퓨터에서는 주소 지정 방식을 여러 가지 혼합하여 사용한다.
초기 단순했던 컴퓨터 구조에서 만들어진 다양한 전통적 설명 체계를 공부한다는 생각으로 알아보는 것이 좋다.


<h3>즉시 주소 지정 방식<sup>immediate addressing Modes</sup></h3>

<center><img src="/assets/images/CS_Instruction/immediate.png"></center><br>
연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식이다. 가장 간단한 형태의 방식으로 메모리나 레지스터로부터 찾는 과정이 없어 비교적 빠르다.  
하지만 연산 코드로 줄어든 양만큼의 작은 범위만 사용할 수 있다는 단점이 있다.


<h3>직접 주소 지정 방식<sup>direct addressing mode</sup></h3>

<center><img src="/assets/images/CS_Instruction/direct_addressing.png"></center><br>
오퍼랜드 필드에 데이터가 저장되는 위치를 명시하는 방식이다. 연산의 대상이 되는 데이터가 저장된 위치를 **유효 주소<sup>effective address</sup>**라고 하는데,
직접 주소 방식에선 이 유효 주소를 할당함으로써 즉시 주소 지정 방식보다 표현할 수 있는 데이터의 크기가 증가한다.


<h3>간접 주소 지정 방식<sup>indirect addressing mode</sup></h3>

<center><img src="/assets/images/CS_Instruction/indirect_addressing.png"></center><br>
유효 주소의 주소를 오퍼랜드 필드에 명시한다. C++의 더블 포인터 개념으로 이해하면 편하다. 직접 주소 지정 방식 보다 표현할 수 있는 유효 주소의 범위가
더 넓어졌지만, 두 번의 메모리 접근이 필요해 일반적으로 느린 방식에 해당한다.


<h3>레지스터 주소 지정 방식<sup>register addressing mode</sup></h3>

<center><img src="/assets/images/CS_Instruction/register_addressing.png"></center><br>
직접 주소 지정 방식과 비슷하지만 유효 주소로 레지스터를 할당한 경우이다. 일반적으로 CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에
접근하는 것이 더 빠르다. 다만 레지스터는 메모리와 비교하여 크기가 더 작기에 제한이 생길 수 있다는 단점이 있다.


<h3>레지스터 간접 주소 지정 방식<sup>register indirect addressing mode</sup></h3>

<center><img src="/assets/images/CS_Instruction/register_indirect.png"></center><br>
오퍼랜드 -> 레지스터 -> 메모리 주소 형식으로 진행된다. 간접 주소 지정 방식과 비슷하지만 메모리에 접근하는 횟수가 한 번으로 줄어들어 더 빠르다.
<!-- 주소 지정 방식에 stack을 이용한 방식 추가 공부 필요 -->

## ISA

모든 CPU에서 실행할 수 있는 명령어들은 다 똑같이 생기지 않고 제조사 마다 다르다. CPU가 이해할수 있는 명령어 구조, 주조 지정 방식, 레지스터 구조들의 모음을 **명렁어 집합 구조<sup>Instruction Set Architecture</sup>**이하 ISA라고 한다.
따라서 CPU마다 서로 다른 ISA를 사용하여, 명령어 집합과 구조가 달라질 수 있다.


<h3>CISC</h3>

CISC는 Complex Instrution Set Computer의 약자이다. 한국어로 해석하면 '복잡한 명령어 집합을 활용하는 컴퓨터' 정도로 해석할 수 있다.
x86, x86-64는 대표적인 CISC 기반의 ISA이다.

CISC의 특징으로, 가변 길이 명령어를 활용한다. 또한 메모리에 접근하는 주소 지정 방식도 다양해서 아주 특별한 상황에서만 사용되는 독특한 주소 지정 방식들도 있다.
CISC는 다양한 길이(1-15바이트)를 요구하는 다양한 명령어 집합을 활용하기에 적은 수의 명령어로도 프로그램을 실행 할 수 있다.
적은 수의 명령어로 인해 컴파일된 프로그램의 크기가 작다는 장점이 있지만, 규격화 되어 있지 않아 파이프라이닝을 어렵게 만들고 하드웨어 설계를 복잡하게 만든다.
파이프라닝 문제로 CPU의 속도를 빠르고 효율적으로 사용할 수 없는 문제가 발생하여 CISC를 보안한 RISC를 사용하기 시작하였다.
<!-- 가변 길이가 어떻게 파이프라이닝에서 문제를 일으키는지 설명 필요 -->


<h3>RISC</h3>

RISC는 Reduced Instruction Set Computer의 약자이다. 이름에서 알 수 있듯이 CISC에 비해 명령어의 종류가 적다.
또한 고정 길이(32비트) 명령어를 사용하여 명령어를 규격화 시켜 파이프라이닝에 최적화 시키고 전력 효율을 높여 모바일과 임베디드에서 강점을 가진다.
하지만 명령어의 수를 줄여 CISC와 비교해 동일한 작업을 위해 더 많은 명령어가 필요하게 되었다.
RISC는 ARM Architecture, RISC-V 등에서 사용한다.



## 데이터의 표현과 저장

명령어에서 오퍼랜드는 데이터 혹은 데이터 위치를 저장한다. 결국 0과 1만을 이용해 우리가 사용하는 숫자나 문자를 표현해야 한다.


<h3>이진법</h3>

**이진법<sup>binary</sup>**란 0과 1만으로 모든 숫자를 표현하는 수의 체계를 의미한다. 1-9까지의 수 표현 및 자리 올림으로 표현하는 십진수와 같이
이진법도 0과 1 그리고 자리올림만으로 모든 수를 표현할 수 있다. 이진수와 십진수를 구분하기 위해 진수 끝에 <sub>(2)</sub> 혹은 <sub>(10)</sub> 같이 진수를 아래첨자로 붙이거나, 이진수 앞에 0b를 붙여 구분할 수 있다.


다만 모든 수를 이진수로 표현하려면 몇 가지 문제가 생긴다. 음수를 표현하기 힘들다는 것이다. 십진수는 -2, -5 처럼 - 부호를 붙이면 간단하지만 0과 1만이 존재하는 컴퓨터는 그럴 수 없다.
그렇기에 음수를 표현하기 위해선 **2의 보수<sup>two's complement</sup>**방식을 사용한다.

2의 보수란 '어떤 수를 그보다 큰 2<sup>n</sup>에서 뺀 값'을 의미한다. 11의 2의 보수는 11보다 큰 2<sup>n</sup>, 즉 100에서 11을 뺀 01이 된다.
쉽게 생각하려면 '모든 수를 뒤집고 1을 더한다'라고 생각해도 무방하다. 결국 계산되는 값을 같기 때문이다.

2의 보수를 취하는 방식을 사용해도 여전히 문제점은 존재한다.
2의 보수에서 표한 가능한 최솟값은 은 -2<sup>n</sup> 이지만 최댓값은 2<sup>n-1</sup> 까지 밖에 못해 생기는 문제점,
실수 표현에는 부적합 하다는 문제점도 여전히 있지만 연산 효율성과 하드웨어 단순화 덕분에 2의 보수가 널리 쓰인다.

<center><img src="/assets/images/CS_Instruction/two's_complement.png"></center><br>




<h3>십육진법</h3>

이진법은 0과 1로 모두를 표현하는 것이라면 **십육진법<sup>hexadecimal</sup>**은 0-9,A,B,C,D,E,F 이렇게 16개를 사용해 표현하는 방법이다.
십육진법은 <sub>(16)</sub>을 붙이거나 숫자 앞에 0x를 붙여 구분한다.

십육진법을 사용하는 주된 이유는, 이진수에 비해 짧은 표현 방식 + 이진수와 십육진수 간의 변환 용이 때문이다.

십육진수를 이진수로 바꾸려면 십육진수의 1비트를 이진수의 4비트로 변환,

<center><img src="/assets/images/CS_Instruction/hexa_to_binary.png"></center><br>

이진수를 십육진수로 바꾸려면 이진수의 4비트를 십육진수의 1비트로 변환할 수 있다.
<center><img src="/assets/images/CS_Instruction/two_to_hexa.png"></center><br>






<h3>문자를 표현하는 방법</h3>

0과 1로 우리가 쓰는 한국어, 영어를 사용하기 위해선 문자 인코딩, 문자 디코딩 작업을 거쳐야 한다.

<center><img src="/assets/images/CS_Instruction/En_De_coding.png"></center><br>

**문자 인코딩<sup>character encoding</sup>**의 과정을 거쳐 ㄱ,ㄴ 같은 문자들이 0과 1로 변하고,  
**문자 디코딩<sup>character decoding</sup>**의 과정을 통해 0과 1이 우리가 이해할 수 있는 ㄱ,ㄴ 로 표시 된다.



<h3>아스키 코드</h3>

**아스키코드<sup>ASCII</sup>**는 American Standard Code for Information Interchange의 약자로 초창기 문자 집합 중 하나이다.
아스키코드는 7비트, 2<sup>7</sup>의 가짓수로 영어 알파벳과 아라비아 숫자, 일부 특수 문자(!,#,$) 등을 표현할 수 있다.

<center><img src="/assets/images/CS_Instruction/ASCII-Table.png"></center>
예를 들어 'A'는 십진수 65라는 '글자에 부여된 고유한 값'인 코드포인트<sup>Code Point</sup>를 가지고 있다.


<h3>EUC</h3>

**EUC<sup>Extended Unix Code</sup>**는 영어만 표현 가능한 ASCII 코드와는 달리 한, 중, 일 등의 다양한 언어를 표현하기 위한 인코딩 방식이다.
한국어를 표현하기 위해 크게 완성형 인코딩 방식과 조합형 인코딩 방식으로 나눌 수 있다.  

**완성형 인코딩 방식**은 한글의 초성, 중성, 종성의 조합으로 이루어진 단어 하나 하나 마다 고유한 코드를 저장하는 방식이고,
**조합형 인코딩 방식**은 초성 비트, 중성 비트, 종성 비트를 조합하여 표현하는 방식이다.

<center><img src="/assets/images/CS_Instruction/encoding_type.png"></center><br>
EUC-KR은 완성형 인코딩 방식으로 작동한다.

<center><img src="/assets/images/CS_Instruction/EUC-KR.png"></center><br>

이 방식을 실제 예시로 살펴보면, '가'라는 글자는 EUC-KR 코드표에서 특정 행과 열에 해당하며 이 값을 조합하면 'B0A1'라는 코드가 된다.
'가'라는 단어를 사용할 땐 컴퓨터에서 B0A1, 이진수로 표현하면 10110000 10100001의 Code Point값을 저장해 놓는 것이다.


<h3>유니코드</h3>

EUC는 크나큰 단점이 존재한다. EUC-KR로 인코딩된 페이지에 한국어와 일본어가 같이 있다면 일본어가 깨져버리는 언어 간의 문제점이 발생했다.
(+ 이모티콘도 표현할 수 없다)

따라서 전 세계 언어를 정의하기 위한 국제 표준인 **유니코드<sup>Unicde</sup>**가 등장하였다.

<center><img src="/assets/images/CS_Instruction/Unicode.png"></center><br>
유니코드에서 '가'의 Code Point는 'AC00'인 것을 볼 수 있다. 여기에 추가로 유니코드는 앞에 'U+'를 붙여서 'U+AC00' 이렇게 표현한다.
유니코드는 모든 문자를 표현할 수 있지만 간단한 문자를 표현하는데 많은 비트를 소모해 메모리 낭비가 심하다는 문제가 있다.


<h3>UTF-8</h3>

가장 대중적으로 사용되는 **UTF-8<sup>8-bit Unicode Transformation Format</sup>**은 문자열 형태를 8bit, 즉 1바이트 단위로 인코딩 한다는 의미이다.
메모리를 효율적으로 사용하기 위해 1byte에서 4byte 까지 가변 크기 인코딩 방식을 사용한다.

UTF-8은 문자 코드의 범위에 따라 바이트 수를 다르게 저장함으로써 메모리를 효율적으로 사용할 수 있다.

<center><img src="/assets/images/CS_Instruction/utf-8.png"></center><br>
'가'의 코드포인트는 (유니코드 표에 따르면) 'U+AC00'이고, 이진수로 표현하면 10101100 00000000이다.
이는 U+800 - U+FFFF 범위에 있으니 1110xxxx 10xxxxxx 10xxxxxx 의 x 자리에 순서대로 유니코드의 값을 채워 넣으면 된다.
이렇게 하면 3바이트로 줄일 수 있다.

즉, 사용 빈도가 높은 글자(영문자, ..)는 적은 저장 공간을 차지하도록 만든 것이다.
기존의 HTML 태그나 자바스크립트 등 ASCII로 구축된 사이트를 별다른 변환 처리 없이 그대로 쓸 수 있는 엄청난 장점 때문에 현재까지도 UTF-8을 많이 사용하고 있다.

+) 추가로 UTF-16은 사용 빈도가 높은 글자는 2비트로 표현, 나머지는 4비트로 표현하는 방식, UTF-32는 모든 문자를 4비트로 처리하는 방식이다.